{% extends 'base.html' %}

{% block title %}{{ market.title }} - Voy a Mi{% endblock %}

{% block content %}
<!-- Breadcrumb -->
<div class="mb-2" style="font-size: 0.85rem; color: var(--text-tertiary);">
    <a href="{% url 'predictions:index' %}">Markets</a> /
    <a href="{% url 'predictions:event_detail' event.slug %}">{{ event.title|truncatewords:3 }}</a>
</div>

<!-- Main Hero -->
<div class="detail-hero">
    {% if market.display_image %}
    <img src="{{ market.display_image.url }}" class="hero-thumb" alt="Market">
    {% endif %}
    <h1 class="detail-title">{{ market.title }}</h1>
    <div class="market-meta" style="justify-content: center;">
        {% if market.is_trading_active %}
        <span class="text-green">● Trading Active</span>
        {% else %}
        <span>● {{ market.get_status_display }}</span>
        {% endif %}
        <span>• Vol: ${{ market.total_volume }}</span>
    </div>

    <!-- Prices -->
    <div class="detail-price-row">
        <div class="price-block">
            <span class="price-label">YES</span>
            <div class="price-value text-yes" id="yes-price">{{ amm_prices.yes_price }}c</div>
            <div style="font-size: 0.8rem; color: var(--text-tertiary);"><span id="yes-implied">{{ amm_prices.yes_price
                    }}</span>%</div>
        </div>
        <div class="price-block">
            <span class="price-label">NO</span>
            <div class="price-value text-no" id="no-price">{{ amm_prices.no_price }}c</div>
            <div style="font-size: 0.8rem; color: var(--text-tertiary);"><span id="no-implied">{{ amm_prices.no_price
                    }}</span>%</div>
        </div>
    </div>
</div>

<!-- Chart -->
<div class="chart-container">
    <div class="d-flex justify-between items-center mb-2" style="padding: 0 8px;">
        <span style="font-size: 0.85rem; font-weight: 600;">Price History</span>
        <div style="display: flex; gap: 4px;">
            <button class="btn-outline" style="padding: 2px 8px; font-size: 0.75rem;" data-timeframe="24h">24H</button>
            <button class="btn-outline" style="padding: 2px 8px; font-size: 0.75rem;" data-timeframe="all">All</button>
        </div>
    </div>
    <div style="height: 200px; position: relative;">
        <canvas id="priceChart"></canvas>
        <div id="chartLoading"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--text-tertiary);">
            Loading...
        </div>
    </div>
</div>

<!-- Trading Interface -->
{% if market.is_trading_active %}
<div class="trading-card">
    <div class="tab-nav">
        <button class="tab-btn active" id="quick-bet-tab" onclick="switchTab('quick')">Quick Bet</button>
        <button class="tab-btn" id="limit-order-tab" onclick="switchTab('limit')">Limit Order</button>
    </div>

    <div class="trade-form">
        {% if user.is_authenticated %}
        <!-- Quick Bet Form -->
        <div id="quick-bet-panel">
            <form method="post" action="{% url 'predictions:place_quick_bet' market.pk %}" id="quick-bet-form">
                {% csrf_token %}
                <input type="hidden" name="price" value=""> <!-- Blank for market order -->

                <!-- Buy/Sell Toggle (Hidden radio, custom UI) -->
                <div class="outcome-selector">
                    <label class="outcome-option selected" id="opt-buy" onclick="setSide('BUY')">Buy</label>
                    <label class="outcome-option" id="opt-sell" onclick="setSide('SELL')">Sell</label>
                </div>
                <!-- Hidden inputs for form -->
                <input type="radio" name="action" id="quick_buy" value="buy" checked class="d-none">
                <input type="radio" name="action" id="quick_sell" value="sell" class="d-none">

                <!-- Outcome Toggle -->
                <div class="outcome-selector">
                    <label class="outcome-option selected yes" id="opt-yes" onclick="setOutcome('YES')">YES</label>
                    <label class="outcome-option no" id="opt-no" onclick="setOutcome('NO')">NO</label>
                </div>
                <input type="radio" name="contract_type" id="quick_type_yes" value="yes" checked class="d-none">
                <input type="radio" name="contract_type" id="quick_type_no" value="no" class="d-none">

                <!-- Amount Input -->
                <div class="amount-input-group">
                    <span class="amount-label" id="amount-prefix">$</span>
                    <input type="number" class="amount-input" name="amount" id="quick_amount" value="5" step="any">
                    <!-- Renamed ID to match JS -->
                    <span class="amount-label d-none" id="shares-suffix">Shares</span>
                </div>

                <!-- Summary -->
                <div class="order-summary">
                    <div class="summary-row">
                        <span>Avg Price</span>
                        <span id="estimate-price">-</span>
                    </div>
                    <div class="summary-row">
                        <span id="estimate-shares-label">Est. Shares</span>
                        <span id="estimate-shares">-</span>
                    </div>
                    <div class="summary-row">
                        <span id="estimate-result-label">Potential Payout</span>
                        <span id="estimate-payout">-</span>
                    </div>
                </div>

                <button type="submit" class="btn btn-primary w-100" id="quick-bet-button"
                    style="font-size: 1.1rem; padding: 14px;">
                    Place Order
                </button>
            </form>
        </div>

        <!-- Limit Order Form (Simplified implementation) -->
        <div id="limit-order-panel" class="d-none">
            <form method="post" action="{% url 'predictions:place_order' market.pk %}">
                {% csrf_token %}
                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                    Limit orders allow you to set a specific price.
                </div>
                <!-- Re-using basic inputs for simplicity in this artifact -->
                <input type="hidden" name="order_type" value="BUY">
                <div class="outcome-selector">
                    <label class="outcome-option selected yes">YES</label>
                    <label class="outcome-option no">NO</label>
                </div>
                <input type="radio" name="outcome" value="YES" checked class="d-none">

                <div class="amount-input-group">
                    <span class="amount-label">Price</span>
                    <input type="number" class="amount-input" name="price" id="price_input" value="0.50" step="0.01"
                        max="0.99">
                    <span class="amount-label">cents</span>
                </div>
                <div class="amount-input-group">
                    <span class="amount-label">Qty</span>
                    <input type="number" class="amount-input" name="quantity" id="quantity_input" value="10">
                    <span class="amount-label">shares</span>
                </div>
                <button type="submit" class="btn btn-outline w-100">Place Limit Order</button>
            </form>
        </div>

        {% else %}
        <div style="text-align: center; padding: 20px;">
            <a href="{% url 'login' %}" class="btn btn-primary w-100">Login to Trade</a>
        </div>
        {% endif %}
    </div>
</div>
{% endif %}

<!-- Orderbook Section (Polymarket Style) -->
<div class="orderbook-section">
    <div class="orderbook-container">
        <!-- Header with tabs -->
        <div class="orderbook-header">
            <div class="orderbook-title">Order Book <span class="orderbook-help" title="View buy and sell orders">?</span></div>
            <div class="orderbook-collapse">▼</div>
        </div>

        <!-- Tab bar -->
        <div class="orderbook-tabs">
            <button class="orderbook-tab active" id="tab-yes" onclick="switchOrderbookTab('yes')">Trade Yes</button>
            <button class="orderbook-tab" id="tab-no" onclick="switchOrderbookTab('no')">Trade No</button>
            <div class="orderbook-refresh">
                <button class="refresh-btn" onclick="fetchOrderBook()" title="Refresh">↻</button>
            </div>
        </div>

        <!-- Column headers -->
        <div class="orderbook-columns">
            <div class="col-trade">TRADE <span id="col-trade-type">YES</span> ▼</div>
            <div class="col-price">PRICE</div>
            <div class="col-shares">SHARES</div>
            <div class="col-total">TOTAL</div>
        </div>

        <!-- Asks section (sells) - displayed with highest price at top -->
        <div class="orderbook-asks" id="orderbook-asks">
            <!-- JS injected - rows will be inserted here -->
            <div class="orderbook-empty">Loading...</div>
        </div>

        <!-- Spread row -->
        <div class="orderbook-spread" id="orderbook-spread">
            <div class="spread-label">
                <span class="asks-label">Asks</span>
            </div>
            <div class="spread-info">
                <span>Last: <span id="spread-last">--</span></span>
                <span>Spread: <span id="spread-value">--</span></span>
            </div>
            <div class="spread-label">
                <span class="bids-label">Bids</span>
            </div>
        </div>

        <!-- Bids section (buys) - highest price at top -->
        <div class="orderbook-bids" id="orderbook-bids">
            <!-- JS injected - rows will be inserted here -->
            <div class="orderbook-empty">Loading...</div>
        </div>
    </div>
</div>

<!-- Trades Section -->
<div class="orderbook-section mb-4">
    <div class="section-title">Recent Trades <span style="font-size: 0.7rem; color: var(--text-tertiary);">(Market #{{ market.pk }})</span></div>
    <div
        style="background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border-color); overflow-x: auto;">
        <table class="orderbook-table">
            <thead>
                <tr>
                    <th>Time</th>
                    <th>Type</th>
                    <th>Price</th>
                    <th class="text-end">Qty</th>
                </tr>
            </thead>
            <tbody id="trades-tbody">
                <tr><td colspan="4" style="color:var(--text-tertiary); text-align:center; padding: 24px;">Loading...</td></tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Tab switching functions -->
<script>
    function switchTab(tab) {
        if (tab === 'quick') {
            document.getElementById('quick-bet-tab').classList.add('active');
            document.getElementById('limit-order-tab').classList.remove('active');
            document.getElementById('quick-bet-panel').classList.remove('d-none');
            document.getElementById('limit-order-panel').classList.add('d-none');
        } else {
            document.getElementById('limit-order-tab').classList.add('active');
            document.getElementById('quick-bet-tab').classList.remove('active');
            document.getElementById('limit-order-panel').classList.remove('d-none');
            document.getElementById('quick-bet-panel').classList.add('d-none');
        }
    }

    function setSide(side) {
        if (side === 'BUY') {
            document.getElementById('quick_buy').checked = true;
            document.getElementById('opt-buy').classList.add('selected');
            document.getElementById('opt-sell').classList.remove('selected');
        } else {
            document.getElementById('quick_sell').checked = true;
            document.getElementById('opt-sell').classList.add('selected');
            document.getElementById('opt-buy').classList.remove('selected');
        }
        document.getElementById('quick_' + side.toLowerCase()).dispatchEvent(new Event('change'));
    }

    function setOutcome(type) {
        if (type === 'YES') {
            document.getElementById('quick_type_yes').checked = true;
            document.getElementById('opt-yes').classList.add('selected');
            document.getElementById('opt-no').classList.remove('selected');
        } else {
            document.getElementById('quick_type_no').checked = true;
            document.getElementById('opt-no').classList.add('selected');
            document.getElementById('opt-yes').classList.remove('selected');
        }
        document.getElementById('quick_type_' + type.toLowerCase()).dispatchEvent(new Event('change'));
    }
</script>

{% endblock %}

{% block extra_css %}
<style>
    /* Clean up flashing animations */
    .price-up {
        color: var(--pm-green);
        transform: scale(1.1);
        transition: color 0.2s, transform 0.2s;
    }

    .price-down {
        color: var(--pm-red);
        transform: scale(1.1);
        transition: color 0.2s, transform 0.2s;
    }

    #priceChart {
        width: 100% !important;
        height: 100% !important;
    }
</style>
{% endblock %}

{% block extra_js %}
<!-- Chart.js for price history -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script
    src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script>
console.log('=== SCRIPT STARTING ===');
(function () {
    'use strict';

    // Market ID for WebSocket connection
    const marketId = {{ market.pk }};
    console.log('Market ID:', marketId);

    // AMM price data from Django (will be updated by WebSocket)
    const marketPrices = {
        yesPrice: {{ amm_prices.yes_price|default:50 }},
        noPrice: {{ amm_prices.no_price|default:50 }},
        // Keep orderbook data for limit orders
        yesAsk: {{ market.best_yes_ask|default:"null" }},
        noAsk: {{ market.best_no_ask|default:"null" }},
        yesBid: {{ market.best_yes_bid|default:"null" }},
        noBid: {{ market.best_no_bid|default:"null" }}
    };

        // WebSocket connection
        let socket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        const reconnectDelay = 2000;

        // Create connection status indicator
        function createStatusIndicator() {
        const indicator = document.createElement('div');
        indicator.id = 'ws-status';
        indicator.className = 'ws-status connecting';
        indicator.textContent = 'Connecting...';
        indicator.style.display = 'none'; // Hide in this design unless needed
        document.body.appendChild(indicator);
        return indicator;
    }

        // Update status indicator
        function updateStatus(status, text) {
            // console.log(status, text); // simplified handling
        }

    // Connect to WebSocket
        function connectWebSocket() {
        const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = wsScheme + '://' + window.location.host + '/ws/market/' + marketId + '/';

        console.log('Connecting to WebSocket:', wsUrl);
        socket = new WebSocket(wsUrl);

        socket.onopen = function (e) {
            console.log('WebSocket connected');
        reconnectAttempts = 0;
        };

        socket.onmessage = function (e) {
            const data = JSON.parse(e.data);
        handleMessage(data);
        };

        socket.onclose = function (e) {
            console.log('WebSocket closed');
        if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
        setTimeout(connectWebSocket, reconnectDelay * reconnectAttempts);
            }
        };

        socket.onerror = function (e) {
            console.error('WebSocket error:', e);
        };
    }

        // Handle incoming WebSocket messages
        function handleMessage(message) {
        const type = message.type;
        const data = message.data || message;  // Handle both nested and flat formats

        switch (type) {
            case 'initial_state':
        updatePrices(data.last_yes_price, data.last_no_price, false);
        marketPrices.yesPrice = data.last_yes_price || 50;
        marketPrices.noPrice = data.last_no_price || 50;
        updateQuickBetEstimate();
        break;

        case 'market_update':
        updatePrices(data.last_yes_price, data.last_no_price, true);
        marketPrices.yesPrice = data.last_yes_price || marketPrices.yesPrice;
        marketPrices.noPrice = data.last_no_price || marketPrices.noPrice;
        updateQuickBetEstimate();
        break;

        case 'trade_executed':
        addTradeToTable(data);
        break;

        case 'orderbook_update':
        // console.log('Orderbook updated:', data);
        break;
        }
    }

        // Update price displays with animation
        function updatePrices(newYesPrice, newNoPrice, animate) {
        const yesPrice = document.getElementById('yes-price');
        const noPrice = document.getElementById('no-price');
        const yesImplied = document.getElementById('yes-implied');
        const noImplied = document.getElementById('no-implied');

        // Update YES price
        if (yesPrice && newYesPrice !== undefined) {
            const oldYes = marketPrices.lastYes || marketPrices.yesPrice;
        if (newYesPrice !== oldYes) {
            yesPrice.textContent = newYesPrice + 'c';
        if (yesImplied) yesImplied.textContent = newYesPrice;
        marketPrices.lastYes = newYesPrice;
        if (animate) {
            yesPrice.classList.add(newYesPrice > oldYes ? 'price-up' : 'price-down');
                    setTimeout(() => yesPrice.classList.remove('price-up', 'price-down'), 500);
                }
            }
        }

        // Update NO price
        if (noPrice && newNoPrice !== undefined) {
            const oldNo = marketPrices.lastNo || marketPrices.noPrice;
        if (newNoPrice !== oldNo) {
            noPrice.textContent = newNoPrice + 'c';
        if (noImplied) noImplied.textContent = newNoPrice;
        marketPrices.lastNo = newNoPrice;
        if (animate) {
            noPrice.classList.add(newNoPrice > oldNo ? 'price-up' : 'price-down');
                    setTimeout(() => noPrice.classList.remove('price-up', 'price-down'), 500);
                }
            }
        }
    }

        // Add new AMM trade to the trades table
        function addTradeToTable(trade) {
        const tbody = document.getElementById('trades-tbody');
        if (!tbody) return;

        const row = document.createElement('tr');
        const time = new Date(trade.executed_at);
        const timeStr = time.toLocaleTimeString('en-US', {hour12: false });
        // Simplified Logic for Artifact
        const actionBadgeClass = trade.side === 'buy' ? 'text-green' : 'text-red';
        const typeColor = trade.contract_type === 'yes' ? 'text-green' : 'text-red';

        row.innerHTML = `
        <td>${timeStr}</td>
        <td style="font-weight:600" class="${actionBadgeClass}">${trade.side.toUpperCase()}</td>
        <td>${trade.avg_price}c</td>
        <td class="text-end">${trade.quantity}</td>
        `;

        tbody.insertBefore(row, tbody.firstChild);
        if (tbody.children.length > 20) tbody.removeChild(tbody.lastChild);
    }

        // Send ping to keep connection alive
        function sendPing() {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'ping' }));
        }
    }

        // Get AMM market price for a contract type
        function getMarketPrice(contractType) {
        if (contractType === 'yes') {
            return marketPrices.yesPrice || 50;
        } else {
            return marketPrices.noPrice || 50;
        }
    }

        function isSellMode() {
        const sellRadio = document.getElementById('quick_sell');
        return sellRadio && sellRadio.checked;
    }

        function updateBuySellMode() {
        const isSell = isSellMode();
        const amountLabel = document.getElementById('amount-prefix');
        const sharesSuffix = document.getElementById('shares-suffix');
        const amountInput = document.getElementById('quick_amount');
        const estSharesLabel = document.getElementById('estimate-shares-label');
        const resultLabel = document.getElementById('estimate-result-label');

        if (isSell) {
            // Sell mode
            if (amountLabel) amountLabel.classList.add('d-none');
        if (sharesSuffix) sharesSuffix.classList.remove('d-none');
        if (amountInput) {amountInput.step = '1'; amountInput.min = '1'; amountInput.value = '10'; }
        if (estSharesLabel) estSharesLabel.textContent = 'Selling:';
        if (resultLabel) resultLabel.textContent = 'You Receive:';
        } else {
            // Buy mode
            if (amountLabel) amountLabel.classList.remove('d-none');
        if (sharesSuffix) sharesSuffix.classList.add('d-none');
        if (amountInput) {amountInput.step = 'any'; amountInput.min = '0.01'; amountInput.value = '5'; }
        if (estSharesLabel) estSharesLabel.textContent = 'Est. Shares:';
        if (resultLabel) resultLabel.textContent = 'Potential Payout:';
        }
        updateQuickBetEstimate();
    }

        // Update Quick Bet estimates
        function updateQuickBetEstimate() {
        const amountInput = document.getElementById('quick_amount');
        const yesRadio = document.getElementById('quick_type_yes');
        const sharesDisplay = document.getElementById('estimate-shares');
        const priceDisplay = document.getElementById('estimate-price');
        const payoutDisplay = document.getElementById('estimate-payout');
        const betButton = document.getElementById('quick-bet-button');

        if (!amountInput) return;

        const isSell = isSellMode();
        const contractType = yesRadio && yesRadio.checked ? 'yes' : 'no';
        const price = getMarketPrice(contractType);
        const contractLabel = contractType.toUpperCase();

        if (isSell) {
            const shares = parseInt(amountInput.value) || 0;
        const payout = (shares * price / 100).toFixed(2);
        if (sharesDisplay) sharesDisplay.textContent = shares + ' shares';
        if (priceDisplay) priceDisplay.textContent = price + 'c';
        if (payoutDisplay) payoutDisplay.textContent = '$' + payout;
        if (betButton) betButton.textContent = 'Sell ' + shares + ' ' + contractLabel;
        } else {
            const amount = parseFloat(amountInput.value) || 0;
        const shares = Math.floor(amount * 100 / price);
        const payout = shares; // $1 per share
        if (sharesDisplay) sharesDisplay.textContent = shares + ' shares';
        if (priceDisplay) priceDisplay.textContent = price + 'c';
        if (payoutDisplay) payoutDisplay.textContent = '$' + payout.toFixed(2);
        if (betButton) betButton.textContent = 'Buy ' + contractLabel;
        }
    }

        // ====== ORDER BOOK & POSITION POLLING ======
        let currentOrderbookData = null;
        let currentOrderbookTab = 'yes';

        function fetchOrderBook() {
            console.log('Fetching orderbook for market:', marketId);
            fetch('/api/markets/' + marketId + '/orderbook/')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Orderbook data received');
                    if (data.orderbook) {
                        currentOrderbookData = data;
                        renderPolymarketOrderbook(data.orderbook, currentOrderbookTab, data);
                    }
                })
                .catch(err => console.error('Error fetching orderbook:', err));
        }

        function switchOrderbookTab(tabType) {
            currentOrderbookTab = tabType;

            // Update tab styles
            const yesTab = document.getElementById('tab-yes');
            const noTab = document.getElementById('tab-no');
            const colTradeType = document.getElementById('col-trade-type');

            if (tabType === 'yes') {
                yesTab.classList.add('active');
                noTab.classList.remove('active');
                colTradeType.textContent = 'YES';
            } else {
                noTab.classList.add('active');
                yesTab.classList.remove('active');
                colTradeType.textContent = 'NO';
            }

            // Re-render with current data
            if (currentOrderbookData) {
                renderPolymarketOrderbook(currentOrderbookData.orderbook, tabType, currentOrderbookData);
            }
        }

        function renderPolymarketOrderbook(book, contractType, marketData) {
            const asksContainer = document.getElementById('orderbook-asks');
            const bidsContainer = document.getElementById('orderbook-bids');
            const spreadLast = document.getElementById('spread-last');
            const spreadValue = document.getElementById('spread-value');

            // Get the relevant data based on tab
            const asks = contractType === 'yes' ? book.yes_asks : book.no_asks;
            const bids = contractType === 'yes' ? book.yes_bids : book.no_bids;
            const lastPrice = contractType === 'yes' ? marketData.last_yes_price : marketData.last_no_price;
            const bestBid = contractType === 'yes' ? marketData.best_yes_bid : marketData.best_no_bid;
            const bestAsk = contractType === 'yes' ? marketData.best_yes_ask : marketData.best_no_ask;

            // Calculate max quantity for depth bars
            const allQuantities = [...(asks || []), ...(bids || [])].map(o => o.quantity);
            const maxQty = Math.max(...allQuantities, 1);

            // Render asks (reversed so lowest price is at bottom, closest to spread)
            const reversedAsks = [...(asks || [])].reverse();
            asksContainer.innerHTML = renderOrderbookRows(reversedAsks, 'ask', maxQty, contractType);

            // Render bids (highest price at top, closest to spread)
            bidsContainer.innerHTML = renderOrderbookRows(bids || [], 'bid', maxQty, contractType);

            // Update spread info
            spreadLast.textContent = lastPrice ? lastPrice + '¢' : '--';
            const spread = (bestAsk && bestBid) ? (bestAsk - bestBid) : null;
            spreadValue.textContent = spread !== null ? spread + '¢' : '--';
        }

        function renderOrderbookRows(rows, type, maxQty, contractType) {
            if (!rows || rows.length === 0) {
                return '<div class="orderbook-empty">No ' + (type === 'ask' ? 'asks' : 'bids') + '</div>';
            }

            let html = '';
            rows.forEach(row => {
                const depthPercent = (row.quantity / maxQty) * 100;
                const total = (row.price * row.quantity / 100).toFixed(2);
                const rowClass = type === 'ask' ? 'ask-row' : 'bid-row';
                const side = type === 'ask' ? 'sell' : 'buy';

                html += `
                <div class="orderbook-row ${rowClass}" onclick="fillPriceFromRow(${row.price})" data-price="${row.price}" data-quantity="${row.quantity}">
                    <div class="depth-bar" style="width: ${depthPercent}%"></div>
                    <div class="trade-cell">
                        <button class="trade-btn" onclick="event.stopPropagation(); instantTrade(${row.price}, ${row.quantity}, '${side}', '${contractType}')" title="Click to trade">⚡</button>
                    </div>
                    <div class="price-cell">${row.price}¢</div>
                    <div class="shares-cell">${row.quantity.toLocaleString()}</div>
                    <div class="total-cell">$${total}</div>
                </div>`;
            });
            return html;
        }

        function fillPriceFromRow(priceInCents) {
            // Fill the limit order price input
            const limitPriceInput = document.getElementById('limit_price');
            if (limitPriceInput) {
                limitPriceInput.value = priceInCents;
                // Trigger change event to update calculations
                limitPriceInput.dispatchEvent(new Event('input'));
            }
            // Also switch to limit order tab if on quick bet
            switchTab('limit');
        }

        function instantTrade(price, quantity, side, contractType) {
            // Prompt for quantity (default to 1)
            const tradeQty = prompt('Enter quantity to trade (available: ' + quantity + '):', '1');
            if (!tradeQty || isNaN(parseInt(tradeQty)) || parseInt(tradeQty) <= 0) {
                return;
            }

            // Create and submit a form to the place_order endpoint
            const form = document.createElement('form');
            form.method = 'POST';
            form.action = '/place_order/' + marketId + '/';

            // Add CSRF token
            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
            const csrfInput = document.createElement('input');
            csrfInput.type = 'hidden';
            csrfInput.name = 'csrfmiddlewaretoken';
            csrfInput.value = csrfToken;
            form.appendChild(csrfInput);

            // Add order type (BUY/SELL)
            const orderTypeInput = document.createElement('input');
            orderTypeInput.type = 'hidden';
            orderTypeInput.name = 'order_type';
            orderTypeInput.value = side.toUpperCase();
            form.appendChild(orderTypeInput);

            // Add outcome (contract type)
            const outcomeInput = document.createElement('input');
            outcomeInput.type = 'hidden';
            outcomeInput.name = 'outcome';
            outcomeInput.value = contractType.toUpperCase();
            form.appendChild(outcomeInput);

            // Add price
            const priceInput = document.createElement('input');
            priceInput.type = 'hidden';
            priceInput.name = 'price';
            priceInput.value = price;
            form.appendChild(priceInput);

            // Add quantity
            const qtyInput = document.createElement('input');
            qtyInput.type = 'hidden';
            qtyInput.name = 'quantity';
            qtyInput.value = parseInt(tradeQty);
            form.appendChild(qtyInput);

            document.body.appendChild(form);
            form.submit();
        }

        // ====== RECENT TRADES ======
        function fetchRecentTrades() {
            console.log('Fetching trades for market:', marketId);
            fetch('/api/markets/' + marketId + '/trades/')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Trades data received:', data.trades ? data.trades.length : 0, 'trades');
                    if (data.trades) {
                        renderTrades(data.trades);
                    } else {
                        renderTrades([]);
                    }
                })
                .catch(err => {
                    console.error('Error fetching trades:', err);
                    const tbody = document.getElementById('trades-tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="4" style="color:var(--text-tertiary); text-align:center; padding: 24px;">Failed to load trades</td></tr>';
                    }
                });
    }

        function renderTrades(trades) {
        const tbody = document.getElementById('trades-tbody');
        if (!tbody) return;

        if (!trades || trades.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="color:var(--text-tertiary); text-align:center; padding: 24px;">No recent trades</td></tr>';
        return;
        }

        let html = '';
        trades.forEach(trade => {
            const time = new Date(trade.executed_at);
        const timeStr = time.toLocaleTimeString('en-US', {hour12: false });
        const actionBadgeClass = trade.side === 'buy' ? 'text-green' : 'text-red';

        html += `<tr>
            <td>${timeStr}</td>
            <td style="font-weight:600" class="${actionBadgeClass}">${trade.side.toUpperCase()}</td>
            <td>${trade.avg_price}c</td>
            <td class="text-end">${trade.quantity}</td>
        </tr>`;
        });
        tbody.innerHTML = html;
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', function () {
        console.log('Market detail page loaded for market:', marketId);
        createStatusIndicator();
    connectWebSocket();
    setInterval(sendPing, 30000);

        // Fetch initial data
        fetchOrderBook();
        fetchRecentTrades();

        // Poll for updates every 5 seconds
        setInterval(function() {
            fetchOrderBook();
            fetchRecentTrades();
        }, 5000);

    // Listeners for Quick Bet
    const quickAmount = document.getElementById('quick_amount');
    const quickYes = document.getElementById('quick_type_yes');
    const quickNo = document.getElementById('quick_type_no');
    const quickBuy = document.getElementById('quick_buy');
    const quickSell = document.getElementById('quick_sell');

    if (quickAmount) quickAmount.addEventListener('input', updateQuickBetEstimate);
    if (quickYes) quickYes.addEventListener('change', updateQuickBetEstimate);
    if (quickNo) quickNo.addEventListener('change', updateQuickBetEstimate);
    if (quickBuy) quickBuy.addEventListener('change', updateBuySellMode);
    if (quickSell) quickSell.addEventListener('change', updateBuySellMode);

    updateQuickBetEstimate();

    // Chart
    setTimeout(initPriceChart, 100);
    });

    window.addEventListener('beforeunload', function () {
        if (socket) socket.close();
    });

    // Chart logic
    let priceChart = null;
    function initPriceChart() {
        const ctx = document.getElementById('priceChart');
    if (!ctx) return;

    priceChart = new Chart(ctx, {
        type: 'line',
    data: {
        datasets: [{
        label: 'YES',
    data: [],
    borderColor: '#00A68C',
    backgroundColor: 'rgba(0, 166, 140, 0.1)',
    fill: true,
    tension: 0.1,
    pointRadius: 0
                }, {
        label: 'NO',
    data: [],
    borderColor: '#E63C3C',
    backgroundColor: 'rgba(230, 60, 60, 0.1)',
    fill: true,
    tension: 0.1,
    pointRadius: 0
                }]
            },
    options: {
        responsive: true,
    maintainAspectRatio: false,
    plugins: {legend: {display: false } },
    scales: {
        x: {type: 'time', display: false },
    y: {display: false }
                }
            }
        });

    loadPriceHistory('24h');
    }

    function loadPriceHistory(timeframe) {
        fetch('/api/markets/' + marketId + '/price-history/?timeframe=' + timeframe)
            .then(r => r.json())
            .then(data => {
                const loader = document.getElementById('chartLoading');
                if (loader) loader.style.display = 'none';

                if (data.price_history && data.price_history.length > 0) {
                    const yesData = data.price_history.map(p => ({ x: new Date(p.time), y: p.yes_price }));
                    const noData = data.price_history.map(p => ({ x: new Date(p.time), y: p.no_price }));
                    priceChart.data.datasets[0].data = yesData;
                    priceChart.data.datasets[1].data = noData;
                    priceChart.update();
                }
            })
            .catch(err => {
                console.error(err);
                const loader = document.getElementById('chartLoading');
                if (loader) loader.textContent = 'Error';
            });
    }

}) ();
</script>
{% endblock %}